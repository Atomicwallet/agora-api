syntax = "proto3";

package kin.transaction.v3;

option go_package = "github.com/kinecosystem/kin-api/genproto/transaction/v3;transaction";
option java_package = "org.kin.gen.transaction.v3";

import "validate/validate.proto";
import "common/v3/model.proto";

service Transaction {
    // GetHistory returns the transaction history for an account,
    // with additional off-chain data if available.
    rpc GetHistory(GetHistoryRequest) returns (GetHistoryResponse);

    // SubmitSend submits a send transaction, which _may_ be whitelisted.
    //
    // If the memo does not conform to the 'memo standard' (todo: name),
    // the transaction is not eligible for whitelisting.
    rpc SubmitSend(SubmitSendRequest) returns (SubmitSendResponse);

    // GetTransaction blocks until the specified transaction is resolved,
    // or until the RPC is cancelled by client / server, or fails.
    //
    // A transaction is resolved if it has succeeded for failed.
    rpc GetTransaction(GetTransactionRequest) returns (GetTransactionResponse);
}

message GetHistoryRequest {
    // Account to get history for.
    common.v3.StellarAccountId account_id = 1 [(validate.rules).message.required = true];

    // An optional history cursor indicating where in
    // the history to 'resume' from.
    Cursor cursor = 2;

    // The order in which to return history items from
    // the cursor.
    Direction direction = 3;
    enum Direction {
        // ASC direction returns all history items in
        // ascending (based on chain order) from the cursor.
        ASC  = 0;

        // SESC direction returns all history items in
        // descending (based on chain order) from _before_ the cursor.
        DESC = 1;
    }
}

message GetHistoryResponse {
    Result result = 1;
    enum Result {
        OK        = 0;
        NOT_FOUND = 1;
    }

    repeated HistoryItem items = 2 [(validate.rules).repeated = {
        min_items: 0
        max_items: 128
    }];
}

message SubmitSendRequest {
    // The raw XDR bytes (not base64 encoded) of the transaction envelope.
    bytes transaction_xdr = 1 [(validate.rules).bytes = {
        min_len: 1
        max_len: 10240
    }];

    // An invoice indicating what the submitted transaction is for.
    //
    // If an invoice is included in this request, it is expected that the foreign key in
    // the transaction memo is the 230-bit prefix of the invoice hash. The submitted
    // invoice will be included in any calls made to the configured webhook(s) of the
    // third-party app the transaction pertains to.
    //
    // The submitted invoice data will only be available for retrieval from the service it
    // was submitted to and not directly from the blockchain nor any other deployments of
    // the service.
    common.v3.Invoice invoice = 2;
}

message SubmitSendResponse {
    Result result = 1;
    enum Result {
        OK = 0;

        // There was an issue with submitting the transaction
        // to the underlying chain. Clients should retry with
        // a rebuilt transaction in case there is temporal
        // issues with the transaction, such as sequence number,
        // or some other chain specific errors. The detail of
        // the error is present in the result xdr.
        INTERNAL_ERROR = 1;

        // Clients should not submit send transactions until
        // they've verified they have sufficient funds.
        INSUFFICIENT_BALANCE = 2;

        // Another invoice with the same invoice hash prefix exists
        // in the store. Clients should regenerate the invoice
        // with a new nonce and resubmit.
        INVOICE_COLLISION = 3;
    }

    // The hash of the transaction, if it was submitted.
    // May be used for other RPCs.
    common.v3.TransactionHash hash = 2;

    // The ledger in which the submitted transaction was included in.
    //
    // Non-zero on success.
    int64 ledger = 3;

    // The transaction result XDR, if a transaction was submitted.
    bytes result_xdr = 4 [(validate.rules).bytes = {
        min_len: 0
        max_len: 10240
    }];
}

message GetTransactionRequest {
    common.v3.TransactionHash transaction_hash = 1 [(validate.rules).message.required = true];
}

message GetTransactionResponse {
    // The state of the transaction. The states are the same as
    // SubmitSend, with the exception of UNKNOWN, which indicates
    // that the system is not yet aware of the transaction. This
    // cano occur if the transaction is still pending, or has been
    // dropped.
    //
    // If the transaction state is UNKNOWN for an extended period of
    // time, it is likely that it was dropped. As a result, clients
    // should limit the total times GetTransaction is called for a
    // an UNKNOWN transaction.
    State state = 1;
    enum State {
        UNKNOWN = 0;
        SUCCESS = 1;
        INTERNAL_ERROR = 2;
        INSUFFICIENT_FUNDS = 3;
    }

    // Non-zero when state == State::SUCCESS
    int64 ledger = 2;

    // Present when state != State::UNKNOWN
    HistoryItem item = 3;
}

message HistoryItem {
    // The hash of the transaction.
    common.v3.TransactionHash hash = 1 [(validate.rules).message.required = true];

    // Contains the transaction result from when the transaction was submitted
    bytes result_xdr = 2 [(validate.rules).bytes = {
        min_len: 1
        max_len: 10240
    }];

    // Contains the transaction envelope for the transaction.
    bytes envelope_xdr = 3 [(validate.rules).bytes = {
        min_len: 1
        max_len: 10240
    }];

    // The cursor position of this item.
    Cursor cursor = 4;

    // If the transaction contained a valid Agora generated memo, then
    // agora_data_url will be present. Clients may use this URL to obtain
    // off-chain data.
    //
    // todo: standardize agora_data_url protocol / spec. likely just a GET
    // with the transaction hash as a parameter.
    common.v3.AgoraDataUrl agora_data_url = 5;

    // If the service was able to resolve, or manages, the off-chain chain
    // data associated with the memo, AgoraData will be populated.
    common.v3.AgoraData agora_data = 6;
}

message Cursor {
    bytes value = 1 [(validate.rules).bytes = {
        min_len: 1
        max_len: 128
    }];
}
