syntax = "proto3";

package kin.transaction.v3;

option go_package = "github.com/kinecosystem/kin-api/genproto/transaction/v3;transaction";
option java_package = "org.kin.gen.transaction.v3";

import "validate/validate.proto";
import "common/v3/model.proto";

service Transaction {
    rpc GetHistory(GetHistoryRequest) returns (GetHistoryResponse);

    // SubmitSend submits a send transaction, which _may_ be whitelisted.
    //
    // If the memo does not conform to the 'memo standard' (todo: name),
    // the transaction is not eligible for whitelisting.
    rpc SubmitSend(SubmitSendRequest) returns (SubmitSendResponse);

    // GetTransaction blocks until the specified transaction is resolved,
    // or until the RPC is cancelled by client / server, or fails.
    //
    // A transaction is resolved if it has succeeded for failed.
    rpc GetTransaction(GetTransactionRequest) returns (GetTransactionResponse);
}

message GetHistoryRequest {
    // todo
}
message GetHistoryResponse {
    // todo
}

message SubmitSendRequest {
    // The raw XDR bytes (not base64 encoded) of the transaction envelope.
    bytes transaction_xdr = 1 [(validate.rules).bytes = {
        min_len: 1
        max_len: 10240
    }];
}

message SubmitSendResponse {
    Result result = 1;
    enum Result {
        OK = 0;

        // There was an issue with submitting the transaction
        // to the underlying chain. Clients should retry with
        // a rebuilt transaction in case there is temporal
        // issues with the transaction, such as sequence number,
        // or some other chain specific errors. The detail of
        // the error is present in the result xdr.
        INTERNAL_ERROR = 1;

        // Clients should not submit send transactions until
        // they've verified they have sufficient funds.
        INSUFFICIENT_BALANCE = 2;
    }

    // The hash of the transaction, which may be used for other RPCs.
    common.v3.TransactionHash hash = 2 [(validate.rules).message.required = true];

    // The ledger in which the submitted transaction was included in.
    //
    // Non-zero on success.
    int64 ledger = 3;

    // The transaction result XDR.
    bytes result_xdr = 4 [(validate.rules).bytes = {
        min_len: 1
        max_len: 10240
    }];
}

message GetTransactionRequest {
    common.v3.TransactionHash transaction_hash = 1 [(validate.rules).message.required = true];
}

message GetTransactionResponse {
    // The state of the transaction. The states are the same as
    // SubmitSend, with the exception of UNKNOWN, which indicates
    // that the system is not yet aware of the transaction. This
    // cano occur if the transaction is still pending, or has been
    // dropped.
    //
    // If the transaction state is UNKNOWN for an extended period of
    // time, it is likely that it was dropped. As a result, clients
    // should limit the total times GetTransaction is called for a
    // an UNKNOWN transaction.
    State state = 1;
    enum State {
        UNKNOWN = 0;
        SUCCESS = 1;
        INTERNAL_ERROR = 2;
        INSUFFICIENT_FUNDS = 3;
    }

    // Non-zero when state == State::SUCCESS
    int64 ledger = 2;

    // Present when state != STATE::UNKNOWN
    bytes result_xdr = 3 [(validate.rules).bytes = {
        max_len: 10240
    }];
}
